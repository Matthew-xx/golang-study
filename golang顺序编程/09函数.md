# 函数

## 函数的格式

    func 函数名(参数列表)（返回类型列表）｛函数体return｝

### 函数参数

#### 定参数

函数的参数是固定的数量。

    func add(a,b int) int{...}

1. 同类型的参数可以缩写，只写1个类型。

#### 不定参数

    func myfunc(a ...int)
    //参数名  ...类型,本例为传递不定数量的整型数据。

1. 没有固定参数，则为0到多个
2. 有n个固定参数，不定参数须放在固定参数末尾，而且至少传n个参数
3. 参数类型为interface{},则可接收任意类型的数据。

### 返回值

1. 有返回值就必须得写return
2. go支持多返回值
3. go在函数结构中可直接给返回值命名，函数体中就可以使用无参数return
4. 多返回值时，不需要的返回值可用_接收并抛弃。

### 函数名

1. 函数名首字符大小写直接觉得函数的可见性。小写私有（本包内可见），大写公有（其他包也可见）
2. 函数名的大小写导致可见性效果同样适用于类型和变量。

## 普通函数调用

    func funcc(c int){
        fmt.Println("c=",c)
    }
    func funcb(b int){
        funcc(b-1)
        fmt.Println("b=",b)
    }
    func funca(a int){
        funcb(a-1)
        fmt.Println("a=",a)
    }
    func main(){
        funca(3)
        fmt.Println("main")
    }
结果：

    c = 1
    b = 2
    a = 3
    main
  
分析：
main()要执行输出main，需要先执行funca(3),funca(3)要执行输出a=3，需要先执行funcb(2),funcb(2)要执行输出b=2,需要先执行funcc(1),而funcc(1)的执行结果是输出c=1，于是顺利输出c=1,然后funcb,funca,main依次被执行。

总结：
如果1个函数的执行过程中需要执行另一个函数，则需要等待它执行完才能执行后面的语句。层层嵌套的函数也不例外。

### 函数递归调用

函数调用自己本身

    func myfunc(a){
        if a = 1{
            fmt.Println("a=",a)
            return
        }
        myfunc(a-1)
        fmt.Println("a=",a)
    }
    func main(){
        myfunc(3)
        fmt.Println("main")
    }

结果：

    a = 1
    a = 2
    a = 3
    main

总结：
函数递归实质就是一个函数在函数体内调用自身，造成循环执行，跟for循环类似。
由于函数调用的性质，必须执行完被调用的函数，才能执行本循环。故函数每次循环调用自身，也就多一次等待解套。在不断嵌套执行自身过程中，函数参数是唯一可变的，故参数被当做结束执行的标志。

常见递归函数的逻辑：

函数参数为初始值，执行语句后，参数变化，判断参数符合否，符合则return，不符合则调用自身传入新的参数，此时外层函数会因调用自身暂时不执行，而在去执行以上过程，一旦参数符合条件，由里到外层层继续执行并返回。

写递归函数时，参考规律：

1.一个函数是需要循环多次执行，每次执行的唯一区别是参数变化，而且是规律变化。
2.开始写这个函数的构造
3.函数体，首先加入参数变化的截止条件，并写入一次执行内容，并return。
4.调用自身，并将参数变化后传入其中。
5.在写入一次执行内容
6.大功告成

递归能做的循环也能做。

## 定义函数类型

函数在go中也存在类型，任何一个具体的函数都可以认为是某一中函数类型的值。

### 函数类型的结构

类似与函数格式，但无函数名 无函数体

### 函数类型使用

使用type关键字，创建一种函数类型

    type Myfunctype func(int,int)int

任何符合这种类型的函数，都可成为它的值。如下面这两个函数

    func Add(a,b int)int{
        return a+b
    }
    func Minus(a,b int)int{
        return a-b
    }
利用函数类型，声明一个该函数类型变量，并尝试赋值。

    var myfunc Myfunctype
    myfunc = Add

于是可以使用该函数类型变量，直接调用函数

    result:=myfunc(1,1)

#### 多态

以上例子体现了面向对象的**多态**思想，即使用同一个myfunc()函数，当分别赋值add和minus时，实现了两个功能。

## 回调函数

函数类型既然是一种类型，而且可以创建这种类型变量，那这个变量作为一个函数的参数会发生什么？

当某一种函数类型的变量作为另一个函数的参数，实现了把一个函数传递到另一个函数内部。

在上面多态的讲解中，可以给函数类型的变量赋不同的值，从而实现不同的功能。而通过把赋值的过程，封装成一个新函数，而函数类型的变量作为参数，使得这种赋值操作更加统一高效。这种方式被成为函数回调

    func cal(a,b int,myfunc Myfunctype)int{
        return myfunc(a,b)
    }
这时主函数可以这么调用

    cal(1,2,add)
    cal(2,1,minus)

### 回调函数的应用

回调函数多用在一套各自小目标的函数操作，到最后抽象成一个大目标的函数操作。比如计算器的加减乘除，四个函数动作，抽象出来都是进行四则运算的这一个大函数动作

## 匿名函数

实现了闭包，即操作作用域外的变量

引用方式操作，改完影响作用域外的变量原值

闭包如果使用外部变量，这些变量就还会继续存在

即多次调用一个包含匿名函数的母函数，母函数内的语句只执行一次。匿名函数每次都执行，而且是在同一块内存上累积执行，在上次执行结果上继续执行

匿名函数无名字

定义同时调用，函数体后面加（）

只定义，再调用。由于没有名字，貌似无法调用了。但是其实可以把整个函数，赋值给一个同函数类型的变量，然后用这个函数名调用。（ps真是没事闲的，直接给名字不好吗）

## defer

先进后出，想像把带有defer的语句按顺序放入一个管子，函数结束前，一个个取出来执行

注意如果程序崩溃，后面的defer并没有来得及放入管道，只会在崩溃后执行已经放进去的部分

如果是延迟调用过程中崩溃的，后面的继续取出执行，最终显示错误。

### defer与匿名函数

匿名函数能改变作用域外的变量值，如果这个匿名函数被延迟调用，则是先把参数传递进去，在延迟调用的。而非最后传参调用一气呵成。
