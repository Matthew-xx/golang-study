# 函数

## 函数的格式

    func 函数名(参数列表)（返回类型列表）｛函数体return｝

### 函数参数

#### 定参数

函数的参数是固定的数量。

    func add(a,b int) int{...}

1. 同类型的参数可以缩写，只写1个类型。

#### 不定参数

    func myfunc(a ...int)
    //参数名  ...类型,本例为传递不定数量的整型数据。

1. 没有固定参数，则为0到多个
2. 有n个固定参数，不定参数须放在固定参数末尾，而且至少传n个参数
3. 参数类型为interface{},则可接收任意类型的数据。

### 返回值

1. 有返回值就必须得写return
2. go支持多返回值
3. go在函数结构中可直接给返回值命名，函数体中就可以使用无参数return
4. 多返回值时，不需要的返回值可用_接收并抛弃。

### 函数名

1. 函数名首字符大小写直接觉得函数的可见性。小写私有（本包内可见），大写公有（其他包也可见）
2. 函数名的大小写导致可见性效果同样适用于类型和变量。

## 普通函数调用

    func funcc(c int){
        fmt.Println("c=",c)
    }
    func funcb(b int){
        funcc(b-1)
        fmt.Println("b=",b)
    }
    func funca(a int){
        funcb(a-1)
        fmt.Println("a=",a)
    }
    func main(){
        funca(3)
        fmt.Println("main")
    }
结果：

    c = 1
    b = 2
    a = 3
    main
  
分析：
main()要执行输出main，需要先执行funca(3),funca(3)要执行输出a=3，需要先执行funcb(2),funcb(2)要执行输出b=2,需要先执行funcc(1),而funcc(1)的执行结果是输出c=1，于是顺利输出c=1,然后funcb,funca,main依次被执行。

总结：
如果1个函数的执行过程中需要执行另一个函数，则需要等待它执行完才能执行后面的语句。层层嵌套的函数也不例外。

### 函数递归调用

函数调用自己本身

    func myfunc(a){
        if a = 1{
            fmt.Println("a=",a)
            return
        }
        myfunc(a-1)
        fmt.Println("a=",a)
    }
    func main(){
        myfunc(3)
        fmt.Println("main")
    }

结果：

    a = 1
    a = 2
    a = 3
    main

总结：
函数递归实质就是一个函数在函数体内调用自身，造成循环执行，跟for循环类似。
由于函数调用的性质，必须执行完被调用的函数，才能执行本循环。故函数每次循环调用自身，也就多一次等待解套。在不断嵌套执行自身过程中，函数参数是唯一可变的，故参数被当做结束执行的标志。

常见递归函数的逻辑：

函数参数为初始值，执行语句后，参数变化，判断参数符合否，符合则return，不符合则调用自身传入新的参数，此时外层函数会因调用自身暂时不执行，而在去执行以上过程，一旦参数符合条件，由里到外层层继续执行并返回。

写递归函数时，参考规律：

1.一个函数是需要循环多次执行，每次执行的唯一区别是参数变化，而且是规律变化。
2.开始写这个函数的构造
3.函数体，首先加入参数变化的截止条件，并写入一次执行内容，并return。
4.调用自身，并将参数变化后传入其中。
5.在写入一次执行内容
6.大功告成

递归能做的循环也能做。

## 定义函数类型

函数在go中也存在类型，任何一个具体的函数都可以认为是某一中函数类型的值。

### 函数类型的结构

类似与函数格式，但无函数名 无函数体

### 函数类型使用

使用type关键字，创建一种函数类型

    type Myfunctype func(int,int)int

任何符合这种类型的函数，都可成为它的值。如下面这两个函数

    func Add(a,b int)int{
        return a+b
    }
    func Minus(a,b int)int{
        return a-b
    }
利用函数类型，声明一个该函数类型变量，并尝试赋值。

    var myfunc Myfunctype
    myfunc = Add
    //注意不是ADD(),否则就成了函数返回值

于是可以使用该函数类型变量，直接调用函数

    result:=myfunc(1,1)

#### 多态

以上例子体现了面向对象的**多态**思想，即使用同一个myfunc()函数，当分别赋值add和minus时，实现了两个功能。

## 回调函数

函数类型既然是一种类型，而且可以创建这种类型变量，那这个变量作为一个函数的参数会发生什么？

当某一种函数类型的变量作为另一个函数的参数，实现了把一个函数传递到另一个函数内部。

在上面多态的讲解中，可以给函数类型的变量赋不同的值(函数名)，从而实现不同的功能。而通过把赋值的过程，封装成一个新函数，而函数类型的变量作为参数，使得这种赋值操作更加统一高效。这种方式被成为函数回调

    func cal(a,b int,myfunc Myfunctype)int{
        return myfunc(a,b)
    }
这时新函数可以这么调用

    re1 := cal(1,2,add)
    re2 := cal(2,1,minus)

### 回调函数的应用

回调函数多用在一套各自小目标的函数操作，到最后抽象成一个大目标的函数操作。比如计算器的加减乘除，四个函数动作，抽象出来都是进行四则运算的这一个大函数动作

## 匿名函数与闭包

匿名函数即没有定义名字的函数。

    func(a,b int)int{
        return a+b
    }

### 匿名函数的调用

1. 定义同时调用，函数体后面加（）

        func(a,b int){
            ...
        }()

2. 赋值给一个函数类型变量，在通过变量调用。

        f := func(a,b int){
            ...
        }
        f()

### 闭包

闭包是包含自由变量的代码块。

1. 匿名函数就是闭包，闭包可以操作代码块外的变量
2. 闭包如果使用了外部变量，只要这些闭包还在被使用，这些变量就还会继续存在。

如定义一个函数test02,返回值是一个匿名函数

    func test02() func() int {
    x := 0
    fmt.Println("初始化后的自由变量值：", x)
    return func() int {
        fmt.Println("匿名函数本次执行的自由变量值", x)
        x++
        return x * x
    }
}

这时主函数调用test02，得到的返回值为一个匿名函数，多次执行匿名函数。

    f := test02()//接收匿名函数
    fmt.Println("开始执行匿名函数")
    fmt.Println("第1次执行匿名函数：", f())
    fmt.Println("第2次执行匿名函数：", f())
    fmt.Println("第3次执行匿名函数：", f())
    fmt.Println("第4次执行匿名函数：", f())

结果

    初始化后的自由变量值： 0
    开始执行匿名函数
    匿名函数本次执行的自由变量值 0
    第1次执行匿名函数： 1
    匿名函数本次执行的自由变量值 1
    第2次执行匿名函数： 4
    匿名函数本次执行的自由变量值 2
    第3次执行匿名函数： 9
    匿名函数本次执行的自由变量值 3
    第4次执行匿名函数： 16

总结

匿名函数（闭包）作为母函数的返回值，当母函数执行时，闭包没有执行，但闭包默默的把母函数中定义在闭包外的变量的引用保存下来。而这个变量也没有因母函数执行结束被释放。当闭包被执行，索取返回值时。闭包会执行1次，并返回值，以满足被执行的要求。但此时仍然没有释放被闭包引用的变量。以便下次执行继续使用。

## defer

1. 先进后出，想像把带有defer的语句按顺序放入一个管子，函数结束前，一个个取出来执行

2. 注意如果程序崩溃，后面的defer并没有来得及放入管道，只会在崩溃后执行已经放进去的部分

3. 如果是延迟调用过程中崩溃的，后面的继续取出执行，最终显示错误。

实例：

    func testA() {
        fmt.Println("aaaaaaaaaaaaaaaaa")
    }
    func testB() {
        fmt.Println("bbbbbbbbbbbbbbbbb")
        panic("panic test")
    }
    func testC() {
        fmt.Println("ccccccccccccccccc")
    }
执行语句顺序

    defer testA()//最后执行
    defer testB()//倒数第二执行
    defer testC()//倒数第三执行
    testA()      //立即执行
    testB()      //继续执行，过程中报错中断
    testC()      //忽略，不执行
    defer testC()//忽略，不执行
结果

    aaaaaaaaaaaaaaaaa
    bbbbbbbbbbbbbbbbb
    ccccccccccccccccc
    bbbbbbbbbbbbbbbbb
    aaaaaaaaaaaaaaaaa
    panic: panic test
    //报错信息显示在尾部

### defer与匿名函数

匿名函数能改变作用域外的变量值，如果这个匿名函数被延迟调用，则是先把参数初始值传递进去，再延迟调用的。而非最后调用时，传入最终的参数值。
