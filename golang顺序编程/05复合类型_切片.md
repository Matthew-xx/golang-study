# 切片

## 切片创建

### 利用数组创建

    a := [5]int{1, 2, 3, 4, 5}
    s := a[2:3:5]

### 利用其他切片创建

用切片创建的切片，都是指向同一底层数组。切片元素一改俱改

### 利用make()直接创建

    s := make([]int, 3)
    //如不指定cap,则cap=len

## 切片的长度和容量

    a[2:3:5]//长度3-2，容量5-2

1. len是指切片的长度，即切片中元素的个数。
2. cap是指切片的容量，即切片当前开辟的内存空间可以存储的元素个数。
3. 当cap不够用时，会自动申请一个翻倍大小的内存空间，并把原来空间的内容全部复制进去。但这样非常耗时
4. 故cap使用时，常指定一个足够大的数字，避免重新申请新内存空间，达到空间换时间的效果。

## 切片的截取

    s := a[:] //切取全部，不指定长度和容量的写法，默认全部
    s2 := s[1:3:5] //切取a[1]到a[2],即2，3，容量为4
    s3 := s[:3] //切取头部到a[3]不含a[3] =s[0:3:3]
    s4 := s[5:] //切取a[5]到末尾,包含a[5]=s[5:10:10]

## 切片与底层数组的关系

1. 声明并初始一个切片

        a := []int{1, 6, 34, 87, 3, 8, 23, 8, 4, 67}

2. 基于此切片，创建一个新切片

        s := a[2:5]
        //s={34,87,3},注意不要设置容量，否则影响接下来二次切片长度的，因为基于切片创建切片虽可以超过原切片len但不可超过cap

3. 修改s[2],并查看s

        s[2] = 88  
        //s={34,87,88}，3被改为88，长度为3容量为8
        //说明新切片基于原底层数组，容量是从底层数组的切口到底层数据结尾位置的长度。

4. 基于切片s,创建新切片s2,注意此时超出了切片s的数据范围

        s2 := s[2:5]

5. 修改s2[2],并查看s2

        //s2={88,8,23}，s2长度为3，容量为6
        //说明新切片还是基于最初始底层数组，容量是从底层数组的切口到底层数据结尾位置的长度。
6. 切片的引用研究

        as := []int{1, 2}
        bs := []int{2, 3}
        as = bs
        bs[0] = 8 //元素一改俱改
        fmt.Println(as, bs)
        bs = []int{6} //整个切片类型赋值，指向的底层数组也就变了
        fmt.Println(as, bs)

总结：

1. 切片类型是一种**引用类型**，其本身存储的是一个指向底层数组的**引用**。
2. 基于切片创建的新切片，不论是创建第几代切片，都是指向同一个底层数组，而且是**可以超过原切片长度**创建新切片的。超过长度的部分直接就是底层数组的值，没有初始化的部分数组元素值为0
3. 当直接操作切片本身时，实际就是在操作切片的**引用本身**，修改它指向另一个底层数组。不会改变指向原底层数据的其他切片值。
4. 当直接操作切片引用指向的底层数组时，其他指向这个底层数组的切片值也会发生变化。

## append()函数

append()可以给切片追加新元素。

1. 创建一个切片s,查看其内容及容量

        s := []int{1}
        //初始内容及容量 [1],1
2. 使用append创建新切片s1,查看s1

        s1 := append(s, 12)
        //追加内容后的新s1 [1,12]容量 2
3. 修改s1[0],查看s,s1

        s1[0] = 8
        // 修改s1[0], 看s,s1
        // s=[1],s1=[8,12]
        //说明指向的不是同一个底层数组。

4. 同理，创建新切片s2，s也指向s2

        s2:=append(s1,18)
        //s2=[8,12,18]
        s=s2
        //s=[8,12,18]

5.append函数追加3个新切片，创建s3

        s3:=append(append(s,s1...),s2...)
        //s3=[8,12,18,8,12,8,12,18]

总结

1. append函数实际根据被追加的切片指向的底层数组，复制了全新的底层数组，返回值为指向新底层数组的新切片引用。
也就是说，append函数追加后的新切片，并不是指向同一个底层数组。而是新的数组副本。
2. 同一类型的切片之间可以随意赋值，不需要长度相同
3. append函数可不仅可以追加多个元素，也可以追加一个同类型切片，但需要加上...将元素打散

## copy()函数

创建两个切片

    slice1 := []int{6, 6}
    slice2 := []int{1, 2, 3, 4}

如果2作为数据源复制到1里：

    copy(slice1, slice2)

结果

   slice1 = [1,2]

如果1作为数据源复制到2里：

    copy(slice2, slice1)

结果

   slice2 = [6,6,3,4]

总结：

1. 切片函数的两个参数，第一个参数为目标切片，第二个参数会源切片。
2. 按位置，一一对应的复制，不一样长度的切片也可复制。
3. 注意与数组之间的赋值相区别

## 切片作函数参数

引用类型数据做函数参数时，传递进函数的是引用的副本，即形参也指向实参的底层数组，这时修改形参的值，就会同步更新到实参。

切片本身是引用类型，作为函数参数时，会将自身对底层数组的引用复制一份，传递进去。故即便函数内部的切片是新创建的切片，但与原切片指向同一底层数组，这是修改切片元素，会同步修改函数外实参对应的切片元素。
