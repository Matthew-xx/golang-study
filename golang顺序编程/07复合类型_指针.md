# 指针

当我们说一个变量时，实际再说变量在内存中的地址，及此内存地址存储的数据，其中前者可使用指针存储。

## 指针与引用的区别

1. 指针由new生成的，指向特定的内存地址，内存空间大小不变。而引用由make生成，指向一个大小可变的内存块大小。

2. 指针本身就保存的内存地址，当指向发生变化时，意味着指针变量有了新值。引用与所指向的内存块的指向关系很灵活，如切片的增长超出了cap指定的大小时，将会重新分配一块更大的内存并将原切片内容复制过去，切片指向了新的内存块，切片原来的内存将会释放并回收。所以切片指向的内存地址是会变的。

总结：引用的实质是用名字操作代替了指针操作，从而屏蔽与简化了这背后的指针操作复杂性。所以可以说，指针类型是最基本的引用类型。

## 指针的声明

### 声明指针

    var  p *int

### 指针赋值

    a := 10
    p = &a

 给p赋值需要取地址符号&

### 指针解引用

    *p = 10

使用*号解除引用，获得指针所指向内存地址的内存数据值。

### 声明指针的指针

    var m **int
    m=&p  //其中p为指针

要取出p的内容即\*P，需使用*(*m),解引用2此

## new()创建安全指针

    p := new(int)
    //此时*p=0

未初始化的指针变量，不要操作

    var p *int
    fmt.Println(p)//这里不报错
    *p = 3343//这里报错

总结：指针与引用，易错点

无论是指针还是引用，当他们没有指向合法的内存时，就给他们赋值等一切修改内存的操作，会引起空指针异常。当然，不涉及内存的操作，如Print(指针或引用)，并没有危险。

## 指针作函数参数

    func swap(a, b *int) {
        //a,b=b,a 错误，一定要是操作内容，而不是操作指针
        *a, *b = *b, *a
        fmt.Printf("swap: a=%d,b=%d\n", *a, *b)
    }
    func main() {
        a, b := 10, 20
        swap(&a, &b)
        fmt.Printf("main：a=%d,b=%d\n", a, b)
    }

传变量地址，通过修改地址内容，进而修改作用域外的变量值

引用类型数据与指针，做函数参数通用总结

参数的传递本质就是**复制**一份内存数据传递进去，值传递是**复制存储值得内存本身**并传递进入函数操作，故不影响**原来内存**的值。

指针传递，是复制一份存储值的**内存地址**给形参进入函数，函数内部操作**形参指向的内容**，就是在修改**实参指向的内容**，故可影响外部实参值。但是操作地址本身，是在操作副本本身。故不影响外部实参值。

引用类型数据，类似于指针传递。是复制一份指向存储值内存的**引用**给形参，函数内部操作形参，就是在修改实参。