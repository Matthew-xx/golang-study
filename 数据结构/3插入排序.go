package main

import "fmt"

// 插入排序原理
// 将数据分成两组，一组有序，一组无序，默认将第一个数据作为有序数据组的初始状态
// 取无序数组中第一个，与有序的数组一一比较，放到合适的位置。
// 重复此过程，直到无序数据被取完，有序数据组排列完成。
func InsertSort(arr []int) {
	count := 0
	// 将数据中第1个数据作为有序数据，故从第2个数据才开始遍历
	for i := 1; i < len(arr); i++ {
		count++
		// i-1永远指代有序数据中的最后1个
		// 如果当前无序数小于有序数据中的最后1个
		if arr[i] < arr[i-1] {
			// 则将当前无序数据暂时存下来（由于是升序，只是比最后1个小，还要跟前一个比，直到找到没他大的）
			temp := arr[i]
			// 继续往前比
			for i-1 >= 0 && arr[i-1] > temp {

				// 只要满足：当前有序数比无序数据大，则有序数据向后移一位。由于被比较的无序数据已经被暂存下来，无需担心被覆盖
				arr[i] = arr[i-1]
				i--
				// 当前移动完成后，将指针移向更往前一位，若他还是比无序数据大，则有序数据向后移一位，同样不需担心覆盖数据，因为被覆盖数据已经移走
			}
			// 终于找到没他大的或者，没有找到没他大的，则直接将数据插入指针位置即可，同样不担心覆盖原数据
			arr[i] = temp
		}
	}
	fmt.Println("比较次数：", count)
}

// 优化比较次数之后
func InsertSort1(arr []int) {
	count := 0
	// 将数据中第1个数据作为有序数据，故从第2个数据才开始遍历
	for i := 1; i < len(arr); i++ {
		count++
		// i-1永远指代有序数据中的最后1个,直接用j指代，这样j--时，不会影响i，从而减少比较次数
		j := i - 1
		// 如果当前无序数小于有序数据中的最后1个
		if arr[i] < arr[j] {
			// 则将当前无序数据暂时存下来（由于是升序，只是比最后1个小，还要跟前一个比，直到找到没他大的）
			temp := arr[i]
			// 继续往前比
			for j >= 0 && arr[j] > temp {

				// 只要满足：当前有序数比无序数据大，则当前有序数据向后移一位。由于被比较的无序数据已经被暂存下来，无需担心被覆盖
				arr[j+1] = arr[j]
				j--
				// 当前移动完成后，将指针移向更往前一位，若他还是比无序数据大，则有序数据向后移一位，同样不需担心覆盖数据，因为被覆盖数据已经移走
			}
			// 终于找到没他大的或者，没有找到没他大的，则直接将数据插入指针位置即可，同样不担心覆盖原数据
			arr[j+1] = temp
		}
	}
	fmt.Println("比较次数：", count)
}

func main() {
	arr := []int{1, 6, 3, 8, 4, 9, 0, 7}
	fmt.Println("排序前：", arr)
	InsertSort(arr)
	fmt.Println("排序后：", arr)
	arr = []int{1, 6, 3, 8, 4, 9, 0, 7}
	InsertSort1(arr)
	fmt.Println("排序后：", arr)
}
