# 协程同步

## 资源竞争问题

并发的特性使得各协程之间独立同步执行，但在实际应用中，各独立的执行主体，都会遇到对共享资源的操作，但正因为资源是共享的，如果各执行主体依旧自顾自的操作，那操作结果就会乱套，引发资源竞争问题。

为什么需要共享资源，直接不要共享不就行了吗？答案是不行，多个执行主体操作同一资源，带来的优势是显而易见的，那就是省资源。另外有些业务目标是必须共享资源才能实现的。

如：现实生活中的考试，所有学生都在同时书写试卷（并发执行），如果排成一队，每个人等待单独考试（串行执行），显然是巨大的时间浪费。再如学生在签到表上签到，显然每个学生签名时，其他学生必须等待，否则会出现，所有学生争抢签到表，而签到表却没有一个正确完整的名字的结果。

### 传统解决方式

引发资源竞争问题的原因是，各线程之间需要共享内存；解决资源竞争问题的关键在于：各线程之间的协调通信。

传统解决方式是同步锁，即当操作共享资源时，将其上锁，只能当前线程操作，其他所有线程堵塞等待操作完解锁后，如果被随机到执行操作共享资源时，重复以上步骤，直至没有等待解锁的线程。

很显然这种方式很直接粗暴，既然需要共享内存，那我就霸占这款内存，其他线程被堵塞，自然就了解怎么回事了。

    package main
    import "fmt"
    import "sync"
    import "runtime"
    var counter int = 0
    func Count(lock *sync.Mutex){
        lock.Lock()
        counter++
        fmt.Println(z)
        lock.Unlock()
    }

    func main() {
        lock := &sync.Mutex{}
        for i := 0; i < 10; i++{
            go Count(lock)
        }
        for{
            lock.Lock()
            c := counter
            lock.Unlock()
            runtime.Gosched()
            if c >= 10 {
                break
            }
        }
    }

在上面的例子中，我们在 10 个 goroutine 中享了变量 counter。每个 goroutine 执行完成后，将counter 的值加 1。因为 10 个goroutine 是并发执行的，所以我们还引入了锁也就是代码中的 lock 变量。每次对 n 的操作，都要先锁锁住，操作完成后，再将锁打开。在主函数中，使用 for 循环来不断检查ounter 的（同样需要加锁）。当其值达到 10 时，说明所
有 goroutine 都执行完毕了，这时主函数返回，序退出。
事情好像开始变得糟糕了。实现一个如此简单的能，却写出如此臃肿而且难以理解的代
码

### channel实现同步

如果说同步锁的方式类似于把房门锁住，仅自己操作。那么channel实现的方式就是，通过通信限制执行条件的方式强制他们排队操作  。总之，传统的解决方式的本质是：通过共享内存来通信，而go语言实现了通过通信来共享内存。

    package main
    import "fmt"
    func Count(ch chan int) {
        ch <- 1
        fmt.Println("Counting")
    }
    func main(){
        chs := make([]chan int， 10)
        for i := 0; i < 10; i++ {
            chs[i] = make(chan int)
            go Count(chs[i])
        }
        for _, ch := range(chs){
            <-ch
        }
    }

## channel

### 声明channel类型变量

    var chanName chan ElementType

在类型之前加了 chan 关键字。 ElementType 指定这个channel 所能传递的元素类型。举个例子，我们声明一个传递类型为 int 的 channel：

    var ch chan int

### make()声明并初始化channel

    ch := make(chan int)

### channel的堵塞特性

1. channel类型变量值不为空时，继续往其中写入数据**瞬间**，会导致所在goroutine堵塞而不能写入，直到其他goroutine从中读取数据。

        ch <- value
2. channel类型变量值为空时，从中读出数据**瞬间**，会导致所在goroutine堵塞而不能读出，直到其他goroutine往中写入数据。

        value := <-ch

正是channel类型的这种特性使它有了能在各协程中通信：

1. 同步goroutine执行的能力，
2. channel本身也能传递有价值的数据。

### 带缓存channel

channel支持缓存区，缓存区可临时存储准备写入channel变量的一组数据或准备从channel读出的一组数据。但**channel本身仅支持保存1个数据**不变。
同样使用make创建，例声明并初始化一个带缓存的channel

    c := make(chan int, 1024)
    // c可容纳1024个int类型的数据。

### 带缓存channel的堵塞特性

当channel带有缓存区，决定堵塞的不再是有没有数据，而是缓存区数据有没有满，这也是缓存区存在的意义。

1. channel类型变量缓存区满时，继续往缓存区写入数据**瞬间**，会导致所在goroutine堵塞而不能写入，直到其他goroutine从中读取数据。

        ch <- value
2. channel类型变量值为空时，继续从中读出数据**瞬间**，会导致所在goroutine堵塞而不能读出，直到其他goroutine往中写入数据。

一个生产者与消费者的典型示例，子协程不断生产数字（10个），而主协程同时不断的消费数字（取得数字并打印）：

        func main() {
            ch := make(chan int, 3)

            go func() {
                //子协程执行前打印缓冲区的情况
                fmt.Printf("管道的剩余数据个数：%d,容量%d\n", len(ch), cap(ch))
                for i := 1; i <= 10; i++ {
                    ch <- i
                    fmt.Printf("子协程放入数据[%d]——>管道，已有数据个数：%d,容量%d\n", i, len(ch), cap(ch))
                }
            }()
            time.Sleep(time.Second * 2)
            for i := 1; i <= 10; i++ {
                num := <-ch
                fmt.Printf("主协程取出数据[%d]管道<——，剩余数据个数：%d,容量%d\n", num, len(ch), cap(ch))
            }
        }

其中一种运行结果:

    管道的剩余数据个数：0,容量3
    子协程放入数据[1]——>管道，已有数据个数：1,容量3
    子协程放入数据[2]——>管道，已有数据个数：2,容量3
    子协程放入数据[3]——>管道，已有数据个数：3,容量3
    主协程取出数据[1]管道<——，剩余数据个数：3,容量3
    主协程取出数据[2]管道<——，剩余数据个数：2,容量3
    主协程取出数据[3]管道<——，剩余数据个数：1,容量3
    主协程取出数据[4]管道<——，剩余数据个数：0,容量3
    子协程放入数据[4]——>管道，已有数据个数：3,容量3
    子协程放入数据[5]——>管道，已有数据个数：0,容量3
    子协程放入数据[6]——>管道，已有数据个数：1,容量3
    子协程放入数据[7]——>管道，已有数据个数：2,容量3
    子协程放入数据[8]——>管道，已有数据个数：3,容量3
    主协程取出数据[5]管道<——，剩余数据个数：0,容量3
    主协程取出数据[6]管道<——，剩余数据个数：3,容量3
    主协程取出数据[7]管道<——，剩余数据个数：2,容量3
    主协程取出数据[8]管道<——，剩余数据个数：1,容量3
    主协程取出数据[9]管道<——，剩余数据个数：0,容量3 
    子协程放入数据[9]——>管道，已有数据个数：3,容量3
    子协程放入数据[10]——>管道，已有数据个数：0,容量3
    主协程取出数据[10]管道<——，剩余数据个数：0,容量3

运行结果有若干种，总结来看。当管道满了之后，才会彻底阻塞写入方协程。
管道空了之后，才会彻底阻塞读出方协程。
不少情况是边写入边读出。也就是写满之后，立马又能写1个了。读出之后，立马又能读1个了。
另外由于printf是在管道动作后发生的，可能会出现 貌似是没放的数据就显示被取出来了。实际上并没有错误
因确实是先放进去在取出的了，只是print(放入)本身被随机到另一个协程后面执行的，打印的值是现在的值。

### 关闭channel

关闭不在使用channel不是必须的，这根文件读写之类的不一样，不会造成句柄泄露，即使不关闭也会被gc回收。但是有时我们需要主动控制关闭它，从而确定他关闭的时间。

go语言内置函数close()可以用来关闭channel。

    close(ch)

注意事项：

1. 试图向已经关闭的channel发送数据会导致panic
2. 关闭已经关闭的channel会导致panic
3. 没有完美的方法能直接判断一个channel是否已经关闭。

基于以上三个注意事项，我们得出推论：

1. 任何情况下，不要在接收端关闭channel，因为发送端无从知晓channel已经关闭
2. 发送端有多个时，也不要在发送端关闭channel，因为其他发送端无从知晓channel已经关闭