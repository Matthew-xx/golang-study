package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan int, 0)

	go func() {
		//子协程执行前打印缓冲区的情况
		//fmt.Printf("管道的剩余数据个数：%d,容量%d\n", len(ch), cap(ch))
		for i := 0; i < 3; i++ {
			fmt.Println("i=", i)
			ch <- i
			//fmt.Printf("管道的剩余数据个数：%d,容量%d\n", len(ch), cap(ch))肯定永远是0,0
		}
	}()
	time.Sleep(time.Second * 5)
	for i := 0; i < 3; i++ {
		num := <-ch
		fmt.Println("num=", num)

	}
	//总结：对于无缓冲区的channel，往里写东西的协程，写不进数据时才会彻底堵塞。
	//从中读取数据的协程，只有读不到数据时候才会彻底堵塞。
	//其他情况，是随机的，比如在写完之后，再写第二次之前期间，是可以运行其他语句的，此时读数据的协程也解除阻塞，两个协程是随机运行的
	//再比如，读完第一次数据，再读第二次之前，也是可以运行其他语句的，此时写数据的协程也解除阻塞，两个协程此时还是随机运行。
	//
	//经测试，绝大多数情况的运行结果为：
	// i= 0
	// num= 0
	// i= 1
	// i= 2
	// num= 1
	// num= 2
	//子协程给管道写入数据后，主协程立马解除阻塞并打印，打印完一个后，再想打印但是没东西了，主协程被阻塞，
	//子协程再次写入，主协程可以启动了，但没启动，直到子协程写不进去时，主协程才启动
	//启动后，子协程继续写入管道，主协程继续执行完毕。
	//也有可能为：
	// i= 0
	// i= 1
	// num= 0
	// num= 1
	// i= 2
	// num= 2
	//子协程写入管道后，主协程可以启动了，但没启动，直到子协程再次写入，写不进去被阻塞，主协程才启动。
	//主协程启动后，子协程继续写入,主协程继续运行，直到没东西可读，又被阻塞。子协程才启动，写入后，主协程又能继续读出数据了。

}
