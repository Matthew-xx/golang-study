package main

import (
	"fmt"
)

func main() {
	a := []int{1, 6, 34, 87, 3, 8, 23, 8, 4, 67}
	fmt.Println("原a：", a)

	s := a[2:5] //s={34,87,3},注意不要设置容量，否则影响二次切片长度，因为基于切片创建切片虽可以超过原切片len但不可超过cap
	s[2] = 88   //3被改为88,注意不要越界，长度为3容量为8，说明新切片按照底层数组，从前往后切片，容量从切口开始到结尾。
	fmt.Println("第1次切片并改值", a)
	fmt.Println("切片s,长度和容量", s, len(s), cap(s))

	s2 := s[2:5] //s={34,87,88}，s2={88,8,23}
	s2[2] = 99   //23被改为99，注意不要越界，长度为3容量为6，说明新切片依旧按照底层数组，从前往后切片，即便超出所基于切片的范围，容量同上
	fmt.Println("第2次切片并改值", a)
	fmt.Println("切片s2,长度和容量", s2, len(s2), cap(s2))
	s3 := a[:2]
	fmt.Println("切片s3,长度和容量", s3, len(s3), cap(s3)) //长度2容量10，说明容量是从底层数组的切口到结尾位置。

	//总结，
	//1. 基于切片创建的新切片，不论是创建第几代切片，都是指向同一底层数组的，
	//2. 是可以超过原切片长度创建新切片的。超过长度的部分直接就是底层数组的值，没有初始化的部分数组元素值为0

	as := []int{1, 2}
	bs := []int{2, 3}
	as = bs
	bs[0] = 8 //元素一改俱改
	fmt.Println(as, bs)
	bs = []int{6} //整个切片类型赋值，指向的底层数组也就变了
	fmt.Println(as, bs)
}

//总结：切片类型是一种引用类型，其本身存储的是一个指向底层数组的引用（指针+其他配置）。
//当直接操作切片本身时，实际就是在操作切片的引用本身。不会改变指向同一底层数据的其他切片值。
//当直接操作切片引用指向的底层数组时，其他指向这个底层数组的切片值也会发生变化。
