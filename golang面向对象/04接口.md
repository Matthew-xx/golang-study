# 接口

接口是GO语言类型系统的基石。接口中会有很多未实现的方法，任何自定义类型如果实现了该接口的**所有函数**则代表已经实现了该接口，并不需要显式的接口声明，所以go实现的是“非侵入式接口”。

## 创建接口

    type Humaner interface {
        sayhi()
    }

## 实现接口

创建1个叫做Student结构体类型，实现Humener接口的所有函数：

    type Student struct {
        name string
        id   int
    }
    func (s *Student) sayhi() {
        fmt.Printf("student say hi:%s,%d\n", s.name, s.id)
    }

创建1个叫做Teacher结构体类型，实现Humener接口的所有函数：

    type Teacher struct {
        addr  string
        group string
    }
    func (t *Teacher) sayhi() {
        fmt.Printf("teacher say hi:%s,%s\n", t.addr, t.group)
    }
创建1个叫做str的string类型，实现Humener接口的所有函数：

    type MyStr string
    func (s *MyStr) sayhi() {
        fmt.Printf("mystr say hi:%s\n", s)
    }
这三个自定义类型的变量(对象)，也都是humaner接口类型。

    var i Humaner
    s := &Student{"mike", 666}
    i = s
    i.sayhi()
    t := &Teacher{"beijing", "go"}
    i = t
    i.sayhi()

只要实现了此接口方法的类型，那么这个类型的变量（接收者类型）就可以给i赋值，这种特性也叫鸭子类型。

## 通过接口实现多态

在函数一节中，通过同一个函数类型变量，被赋值不同函数实现了多态。

通过接口也可以是实现函数的多态

方法1：定义一个新函数，以接口类型的变量为参数：

    func WhoSayHi(i Humaner) {
        i.sayhi()
    }
这时可调用这同一个函数实现多态

    s := &Student{"mike", 666}
    t := &Teacher{"beijing", "go"}
    var str MyStr = "hello mike"
    WhoSayHi(s)
    WhoSayHi(t)
    WhoSayHi(&str)
方法2：定义一个接口类型的切片，存储三个实现该接口的类型的变量。通过遍历，调用变量的接口方法

    //make为humaner接口类型的切片开辟内存
    x := make([]Humaner, 3)s
    x[0] = s
    x[1] = t
    x[2] = &str
    for _, i := range x {
        i.sayhi()
    }

## 接口的继承
