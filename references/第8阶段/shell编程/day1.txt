shell编程
第一天，shell，语法，运行机制，常用命令
第二天，持续集成的案例

1 软件工程的自动化实现：
	shell实现
	
2 shell
	1 概念：命令解释器
		操作系统和应用程序之间的接口
		
	2 分类：
		一般指linux下命令行shell（重点bash）
		
	3 查看shell信息命令
		1，查看当系统shell：echo $SHELL
		2， 查看当前系统兼容性支持的shell们：
			cat /etc/shells
			
	4 shell脚本：
		概念：命令放到文件中，执行文件（执行脚本）

3 脚本创建
	1， 用vim创建
	2，名称要有意义，.sh结尾
	3，脚本首行#!/bin/bash（指定解释器）
	4，注释：
		1 单行注释：#开头
		2 多行注释：:<<字符 ... 字符（将字符们作为输入重定向到啥都不干）

4 脚本执行
	1 bash 脚本名 （启动子bash，在子bash中执行脚本内命令）
	2 ./脚本名 （启动子bash（名字叫脚本名），在子bash中执行脚本内命令）
	3 source 脚本名 （不启动子进程，直接在当前环境运行脚本内命令）
	
5 开发规范
	1 不要中文注释
	2 成对内容一次性写
	3 缩进（风格类似go）
	
	
6 变量定义：
	1 普通变量
		1,变量名=变量值（不可以有特殊字符）
		2，变量名='变量值' （原封不动输出）
		3，变量名="变量值" （变量套变量）
		
	2 命令变量
		定义方式一： 变量名=`命令` 注意：`是反引号
		定义方式二： 变量名=$(命令)
		
		命令变量值只在定义时确定，不会随着后续命令输出的改变而改变
	
7 变量访问
	方式一： $变量名
	方式二： "$变量名" （变量值作为字符串）
	方式三： ${变量名} （限定变量名范围）
	方式四：标准使用方式 "${变量名}" （最推荐）

	unset 变量名

8 变量分类
	1 本地变量
		哪里定义哪里访问
	2 全局变量（环境变量）
		1 查看当前环境的全局变量：
			env
		2 定义全局变量
			1 先定义后转换
			2 export 变量名=值
			
		3 生效范围
			当前shell环境及子shell环境有效，shell退出后全局变量消失
			
			要想所有环境都生效：
				1 定义到~/.bashrc （对用户有效，打开新终端或source执行生效）
				2 定义到/etc/profile （对所有用户生效，重启或source执行生效）

	3 shell内置变量
		脚本相关：
			$0 脚本文件名
			$$ 执行脚本的进程号
			$n 脚本的第n个命令行参数
			$# 参数个数
			$? 上一条命令的返回值（0代表成功，非0代表失败）
				（若上一条命令是执行脚本---》获取脚本最后一条命令的返回值）
		
		字符串截取
			${变量名:起始位置:截取长度}
			echo ${a:0-3:2} （从倒数第三个开始截取，向后截取2个字符）
		
		默认值：
			${变量名:-默认值} （变量值存在则输出变量值，不存在则输出默认值）
			${变量名:+提示信息} （变量存在则输出提示信息）

			
9 表达式
	将逻辑转成控制
	1 测试语句
		test 条件
		["空格"条件"空格"]
		
		数值比较(比较符两边各有一个空格)
			n1 -eq n2 相等
			n1 -gt n2 大于
			n1 -ge n2 大于等于
			n1 -lt n2 小于
			n1 -le n2 小于等于
			n1 -ne n2 不等于
			
		字符串比较：(比较符两边各有一个空格)
			==  != 
			
	2 逻辑表达式
		命令1 && 命令2 && 命令3
		1成功则执行2,2成功则执行3
		
		命令1 || 命令2 || 命令3
		1 失败则执行2 2 失败则执行3
	
	3 文件表达式
		-f 判断是否是文件
		-d 判断是否是目录
		-x 判断是否可执行 （目录一般可执行）
	
	4 计算表达式（只支持整数运算）
		$(( 计算过程 ))
		let 等式
	
10 常见符号

	1 重定向（> 覆盖重定向，>>追加重定向）
		应用程序有两份输出：
			1 标准输出（程序正常运行时输出的）
			2 标准错误（程序遇到问题时的输出）

		分别重定向	
			bash 6-chongdingxiang.sh 1> res.log 2>err.log
		合并重定向
			bash 6-chongdingxiang.sh > res.log  2>&1
		丢弃
			bash 6-chongdingxiang.sh > /dev/null  2>&1
	2 管道符
		命令1 | 命令2 
		（命令1的输出作为命令2的输入---》命令2要能接收输入）
	
	3 后台展示符
		命令 &
		（将命令放到后台执行，不占用当前终端）
		
			
11 常用命令
	1 grep（搜索）
		grep -rn bash .
		（在当前目录以及子目录中的所有文件中，搜索包含bash的行，并打印行号）
	
	2 find （文件查找）
		find . -name "*sh"
		（在当前目录以及子目录下搜索shell脚本文件）
	3 sed (基于行的文件编辑工具)
		-i 修改源文件
	
		修改：
			sed  "2s#sed#SED#2" sed.txt
			（2（第二行，不写就是所有行）s（替换）#sed（原内容）#SED（替换后内容）#2（第2个找到的--》g代表全部替换））
		
		增加：
			sed "2a\hello" sed.txt
			（2（第二行）a（下边增加）\hello（增加的内容））
			sed "4i\world" sed.txt
			（4（第四行）i（上方增加）\world（增加的内容））
		删除：
			sed "3d" sed.txt 
			（3（第三行）d（删除））
	4 awk （基于行，分割成列 编辑工具）
		awk '{print $3,$1}' awk.txt
		（对awk.txt文件中的每一行，都执行，打印第三例和第一列）
		
		内置变量：
			FILENAME 文件名
			NR 行号：
				awk 'NR==3 {print $4}' awk.txt
				（只对第3行执行打印动作）
			NF 列数：
				awk '{print $NF}' awk.txt
				（打印文件的最后一列）
			FS 行分隔符：
				awk 'BEGIN{FS="a"} {print $2}' awk.txt
				（指定a作为每一行的分隔符）
				
				awk -F "a" '{print $2}' awk.txt
				（指定a作为每一行的分隔符）---》推荐
			OFS：多个输出直接的连接符
				awk 'BEGIN{OFS="->"} {print $2,$4}' awk.txt
				（指定第二列和第四列输出直接用->链接）
				
12 分支
	1 if
		if [ 条件 ]
		then
			 指令1
		elif [ 条件2 ]
		then
			指令2
		else
			指令3
		fi
	2 case
		case 变量名 in
		   值1)
			  指令1
				 ;;
		   ...
		   *)
			 其他情况
				 ;;
		esac
		
13 循环
	1 for
		for 值 in 列表 （包含多个字符串的变量--》一般是命令变量）
		do
		   执行语句
		done
	2 while
		while 条件
		do
		   执行语句
		done
		
14 函数
	定义：
		函数名() {
			函数体
			$n 代表第n个参数
			return (0~255数字)
		}
	调用：
		函数名 参数1 参数2
		$?获取函数返回值
		
	命令变量也适用于函数
15 shell中可执行命令的种类
	1，应用程序 file `which 命令`---》executeable
	2，脚本     file `which 命令`---》shell script
	3，函数 （上述命令查不到）
	
	

		
		
	
	
	
		


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	