# solidity基本数据类型

## 值类型与引用类型

包含

- 布尔
- 整型系列
- 地址
- 定长字节数组
- 有理数和整型
- 枚举类型
- 函数

### 值类型

值类型，在函数参数传递过程中，直接拷贝值到新内存：

- 效率低
- 独立，不互相影响

适合传递简单数据。

#### 布尔类型

可进行逻辑操作

#### 整型

整型分为有符号int和无符号uint

int8,int16,int24,int32,int40......int256,步长为**8位**，共32种大小类型，int=int256

#### 地址类型

专门用来存储以太坊地址。故本质是个20字节数字，被包装成的对象，可以用**uint160**来编码强转

可以进行比较运算

自带一些基本方法，如balance,send

#### 定长字节数组

solidity的定长数组特点：

- 全部内置，用户不可自定义长度。
- bytes1,bytes2......bytes32,步长为**1字节**
- byte=bytes1
- 长度和单个元素内容只可读，**不可改**


### 引用类型

在函数参数传递过程中，传递指针，新变量与原变量共享内存

- 效率高
- 不独立，会互相影响

适合传递复杂的数据。

低版本solidity，默认是按照值类型处理的，想发挥引用类型的原本作用，需要使用**storage**来修饰。
高版本solidity已经改进，去掉了缺省的默认传递方式，全部需要显式声明。

包含

- 不定长bytes
- string
- mapping

#### 不定长字节数组bytes

特点：

- 与内置的定长bytes不同，不定长数组，内容和长度均可以修改
- 于golang的切片不同，bytes无需主动开辟空间完成初始化
- 通过new 一个对象，直接开辟空间
- 通过直接赋值，完成初始化
- 通过push追加新内容，完成初始化
- 通过设置length，完成初始化
- 不主动初始化，不代表不需要初始化，未初始化情况下如果直接下标访问元素，会报错

#### 字符串string

特点：

- 底层是由Utf-8编码的字符串，是特殊的可变字节数组。
- 引用类型
- 与不定长bytes不同，不支持下标索引，不支持length，不支持push
- 可以修改，但需要通过bytes转换

## 自定义类型

### 自定义类型的定长数组

语法：T[K]

特点类似于其他语言的数组，内容可变，长度不可变，支持length，**不支持push**

### 自定义类型的不定长数组

语法：T[]

特点类似于go语言的切片，内容可变，长度可变(但仅限于storage传递方式），支持length,push
很容易理解，go语言中的切片本质是指向一个底层数组的指针，这里实现的更简单，需要显式依赖一个底层数组。故需storage。

### mapping

语法：mapping(T => T)

底层key存储的是key的hash,而不是key本身。类似于goang的map，

        - value可以是任意类型（除映射）
        - 内容无序

但也有一些不同的特点

        - 不能判断某个key是否存在，因为默认所有存在，默认为0或false
        - 不支持length，可理解为默认无限长。

## 状态变量与局部变量

状态变量类似于全局成员变量，在solidity中，状态变量是要上链的，可供外部访问。
局部变量与其他语言的局部变量特性一样

## 函数

### 匿名函数

没有函数名，没有参数，没有返回值的函数，称为匿名函数，当用户调用一个不存在的函数时，会自动调匿名函数。

匿名函数的应用：

- 接受转账，快速，手续费低

        使用payable修饰即可
- 拒绝他人向本合约转账

        函数体直接throw

- 处理其他异常用户操作
