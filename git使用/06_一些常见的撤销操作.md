# 操作撤销、版本回退与HEAD指针

## 撤销上次提交并重新提交commit

    git commit --amend
此选项像是一个追加操作，因为她并不完全撤销上一次的提交信息。

## 把文件从暂存区撤回到未暂存状态

    git reset HEAD <file>

## 丢弃工作区的修改

    git checkout -- <file>
两种情况：

1. 回到暂存区的版本，
2. 如果没有暂存过，回到git库中最后一次commit的版本。

注意**该操作危险，不可撤销**，如果你想撤销未保存的操作，为何不使用编辑器自带的ctrl+Z呢？

## 回到某个文件到git库中的某个版本

    git reset --hard <commit id：部分哈希值>
此操作强制把文件回退到git库中的某个版本，如果想会到未来的版本，需要找到那个版本的commit id,查找命令

## HEAD与rest详解

HEAD指向当前分支**最后一次commit**的文件版本。也就是如果要提交新内容，新commit会成为HEAD的新父节点。

reset命令专门用来操作HEAD指针。

常见命令：

### 重置HEAD指针，但不改变指向

    git reset HEAD [<file>....]

本来不会有任何影响，但是此命令有个默认参数--mixed，效果时清空暂存区。这直接导致已暂存的内容被撤回，如果后面跟文件名。会过滤影响范围只会对此文件起作用。**于是此命令被用来编辑暂存区。**

    git reset [-mixed] <commit号>
此命令 将HEAD指针指向历史中的某次提交。注意，此时不仅HEAD指针指向特定的commit，当前分支也会以这个commit作为结尾。后面的节点仍然存在于git库中，但已经被废弃了（git会当它不存在，除非你主动按照commit号找到它进行操作）。

#### 找回被HEAD和branch废弃的commit

    git reflog

### checkout 提交与它的区别

checkout  <commit号>也会操作HEAD指针，有啥区别？

    git checkout <commit号>
此时master分支还是以最后一次commit提交为结尾而且暂存区内容不受影响。如果此时的HEAD位置上执行新commit，则会在HEAD指向的位置创建新分支来提交。因为你在旧节点基础上创建新分支节点，内容无法追加提交最长节点上。**checkout有此特性，是因为他本来就是用来分支管理的。**

### 按照相对位置操作HEAD

    git rest HEAD~1
操作HEAD指针相对移动若干个位置。1代表向前移动一个位置。

### git rest的参数

git reset的默认有三个恢复等级，参数有三个

1. -soft 
    仅仅将HEAD指针恢复到某个位置，暂存区内容和工作区内容不变。
    这样操作后，直接commit会

2. --mixed
    将HEAD指针恢复到某个位置，暂存区也清空，但工作区内容不变
3. --hard
    将HEAD指针恢复到某个位置，暂存区也清空，工作区也回到那个位置的版本。

另外，暂存区内容就是HEAD即将要指向的内容